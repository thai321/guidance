u4 = User.create(username: 'Pythagoras', email: 'pythagoras@example.com', password: '123456')
u4.image = File.new("#{Rails.root}/app/assets/images/pythagoras.jpg")
u4.save

# user_ids = []
# User.all.map do |u|
#   user_ids.push(u.id) if u4.id != u.id
# end
#
# u4.follower_ids = user_ids
# u4.save

p4 = Project.create(
  title: "Improved Arduino Rotary Encoder",
   description:
    "<p><strong class=\"ql-size-large\"><em>Rotary encoders are great input devices for electronics projects - hopefully this Instructable will inspire and help you use one in your next project.</em></strong></p><p><strong class=\"ql-size-large\">Why write rotary encoder code?</strong></p><p><span class=\"ql-size-large\">I wanted to use a low cost rotary encoder as an input mechanism for one of my upcoming projects and was initially bewildered by the&nbsp;</span><a href=\"http://playground.arduino.cc/Main/RotaryEncoders\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">code options available to take readings from the rotary encoder</a><span class=\"ql-size-large\">&nbsp;and determine how many \"detents\" or cycles the encoder had clicked past and in what direction. I think my main sketch will need to use most of my Arduino's memory so I am avoiding the various available encoder libraries, which seemed to be difficult to make work when I tried a couple of them. They also appear to use far more of the code budget than the sketch-based code approaches discussed from here on.</span></p><p><em class=\"ql-size-large\">If you just want to bypass the thinking behind my approach and get straight into the Instructable, feel free to skip ahead to Step 1!</em></p><p><strong class=\"ql-size-large\">Other Approaches</strong></p><p><span class=\"ql-size-large\">Several of the main sketch-based (i.e. they don't use a library) approaches are discussed in&nbsp;</span><a href=\"http://practicalusage.com/arduino-using-a-rotary-encoder/\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">rt's blog post where they write rotary encoder code</a><span class=\"ql-size-large\">&nbsp;that makes the cheapest encoders usable as Arduino inputs. They also have a good example of they logic signal that the encoder produces. rt found that a timer interrupt system worked best for them but I'm concerned that the polling frequency would detract from screen update speed in the main loop of my project sketch. Given that the rotary encoder will be moving for a tiny proportion of the time I want the screen to be updating, this seems a poor match for my application.</span></p><p><span class=\"ql-size-large\">I chose to start off using&nbsp;</span><a href=\"http://arduinotronics.blogspot.co.uk/2013/09/using-rotary-encoder-with-arduino.html\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">Steve Spence's code here</a><span class=\"ql-size-large\">, which was fine on it's own but appeared to really slow down when I incorporated the rest of my sketch code (which involves writing display updates to a small TFT screen). Initially I wondered if it could be because the main loop contains a debounce statement.</span></p><p><span class=\"ql-size-large\">I then read&nbsp;</span><a href=\"https://www.circuitsathome.com/mcu/rotary-encoder-interrupt-service-routine-for-avr-micros\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">Oleg's rotary encoder article</a><span class=\"ql-size-large\">&nbsp;on an&nbsp;</span><a href=\"http://www.gammon.com.au/forum/?id=11488\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">interrupt service routine</a><span class=\"ql-size-large\">&nbsp;version of his previous post, I also thought it might be a good idea to use direct port manipulation to read both pins simultaneously and as soon as the interrupt fires. His code can be used on any input pin if the port manipulation code is rewritten. In contrast, I decided to use only the hardware interrupts on digital pins 2 and 3, so we can set interrupts to only fire on a rising edge of the pin voltage, rather than on pin voltage change, which includes falling edges. This reduces the number of times the ISR is called, distracting from the main loop.</span></p><p><span class=\"ql-size-large\">Oleg's code uses a lookup table to reduce compiled code size to a really small size but I couldn't get reliable results which would catch very slow rotation as well as reasonably fast rotation. Bear in mind that hardware debouncing (see Step 2) can help a lot with reliability of readings but I was after a software solution to simplify the hardware build and be as portable to other hardware applications as possible.</span></p><p><span class=\"ql-size-large\">This concludes the introduction of my challenge and considerations. In Step 2 we'll take a look at the encoder hardware, terminology and some practical considerations when you want to integrate a rotary encoder into your project.</span></p>",
   video_url: "",
   published: true,
   author_id: u4.id,
)

ProjectTag.create(project_id: p4.id, tag_id: 1)

Step.create(
  title: "A Bit About Rotary Encoders",
 body:
  "<p><strong class=\"ql-size-large\"><em>Why are rotary encoders so cool?</em></strong></p><ol><li><span class=\"ql-size-large\">Unlike a variable resistor/potentiometer they have infinite travel in any direction and because they produce a&nbsp;</span><a href=\"https://en.wikipedia.org/wiki/Gray_code\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">digital \"Gray code\"</a><span class=\"ql-size-large\">&nbsp;you can scale their readings to whatever range you like.</span></li><li><span class=\"ql-size-large\">The dual direction makes them useful for increasing or decreasing a value within a variable or navigating menus.</span></li><li><span class=\"ql-size-large\">Finally, many of these rotary encoders come with a centre push button, which can be used to select menu items, reset a counter or do anything you can think of that might suit a momentary push button.</span></li></ol><p><strong class=\"ql-size-large\">Terms</strong></p><ol><li><strong class=\"ql-size-large\">PPR:&nbsp;</strong><span class=\"ql-size-large\">pulses per rotation - typically 12, 20 or 24. You might also see specifications for maximum rotation in rpm etc. This is probably determined by the encoder's propensity to \"bounce\" contacts - see below.</span></li><li><strong class=\"ql-size-large\">Detent:</strong><span class=\"ql-size-large\">&nbsp;the little click of the action as it springs to a natural rest point between pulses. There may be one detent per pulse/cycle (not equal to a rotation of the shaft) or two.</span></li><li><strong class=\"ql-size-large\">Bounce:&nbsp;</strong><span class=\"ql-size-large\">mechanical contacts inside the encoder literally bounce enough to jump off and back on a contact when rotating, potentially leading to too many readings attributed to that phase of the travel between detents.</span></li><li><strong class=\"ql-size-large\">Debounce:&nbsp;</strong><span class=\"ql-size-large\">This can be either done in hardware, perhaps with a low value ceramic capacitor between each pin and Ground, or in software, perhaps with a delay. In either case, the aim is to create a system which ignores bouncing contacts.</span></li></ol><p><strong class=\"ql-size-large\">Tips</strong></p><ol><li><span class=\"ql-size-large\">Look out for a threaded section near the base of the shaft and a matching nut if you want to mount your encoder in a panel or enclosure.</span></li><li><span class=\"ql-size-large\">Many knobs are available for rotary encoders, with the most easily available coming in 6mm diameter shafts.</span></li><li><span class=\"ql-size-large\">Pay attention to whether your encoder shaft uses a flat face or splines to achieve a proper fit with the knob.</span></li><li><span class=\"ql-size-large\">The body of the rotary encoder may also come with a raised pin/stub, intended to mate with a small indent/hole in your panel (probably hidden by your knob) and prevent your encoder from rotating when you turn the knob. You might find you want to remove this if you can create enough friction to prevent encoder body rotation using the mounting bolt to screw the encoder in the panel or enclosure.</span></li><li><span class=\"ql-size-large\">Make sure you find out where the detent state is for your encoder and adapt your code accordingly. My example uses an encoder whose pins are both disconnected from ground and are pulled high by their respective input pullup resistors. This drives my selection of a RISING interrupt. If both pins were connected to ground when at detent, they would need code which was looking for FALLING pin voltage.</span></li></ol>",
 project_id: p4.id,
)


Step.create(
  title: "The Circuit",
  body:
   "<p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">The circuit is so simple. You will need:</span></p><p><br></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">• An ATMEGA328P based Arduino, such as the Uno, Pro Mini or Nano.&nbsp;</span></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">• A mechanical (as opposed to optical) quadrature rotary encoder - this is the most common kind so don't worry too much if it isn't specified. eBay and Aliexpress listings will often mention Arduino in the description and this is a good indicator that one is suitable.&nbsp;</span></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">• Hook-up wire/jumper leads.&nbsp;</span></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">• Optional: a prototyping breadboard.&nbsp;</span></p><p><br></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">First of all, look for a collection of three pins on one side of the encoder. These are the three for measuring rotation with our code. If there are two pins together on another side, these are likely to be for the centre push button. We'll ignore these for now.&nbsp;</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">Out of the three pins together, the encoder ground pin is connected to Arduino ground pin. Either of the other two pins is connected to digital pin 2 and the remaining on is connected to digital pin 3. If your direction of rotation isn't the way you'd like, just swap the two non-ground pins over.</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">Pins 2 and 3 are important because on the ATMEGA328P-based Arduinos they are the only pins which have the ability to detect RISING and FALLING pin change interrupts. The MEGA 2560 boards etc. have other hardware interrupt pins which can do this.</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">Note: In the diagram the ground pin is one of the end pins. In reality, the ground pin is often the centre pin but this is not always the case so read the datasheet or test your encoder to find out which pin is ground.</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">Another note: ArneTR made a good comment about not having a separately wired connection to the logic positive voltage (e.g. 5V or 3.3V) for the rotary encoder circuit shown. The Arduino can't read the rotary encoder without both a ground signal (which we have connected a wire to) and the logic voltage (sometimes annotated as Vcc or Vdd), so how can the Arduino read the logic from this encoder without a positive voltage wire? The answer is that the ATMEGA328P chip in the Arduino has a special mode you can set on the digital pins (which we are using) where a pin is automatically pulled \"high\" to the logic voltage by an internal resistor. Look in the code for \"pinMode(pinX, INPUT_PULLUP)\" to see us telling the Arduino that we want to take advantage of this mode. Once set, we only need to provide the encoder with a ground wire as the sensing wires from the digital pins are already providing the logic voltage.</span></p><p><br></p><p><span style=\"color: rgb(51, 51, 51);\" class=\"ql-size-large\">ONE MORE THING... Githyuk found that a particular branded encoder didn't work with this way of doing things (ie the code below). Please see the comments section for details but in general, trying a different encoder would be a good debugging step when you have exhausted the easier/faster/cheaper steps.&nbsp;</span></p>",
  project_id: p4.id,
)


Step.create(
  title: "The Code",
  body:
   "<p><span class=\"ql-size-large\">If you are not familiar with programming Arduinos, please get up to speed with this&nbsp;</span><a href=\"https://www.arduino.cc/en/Guide/HomePage\" target=\"_blank\" style=\"color: rgb(232, 108, 0);\" class=\"ql-size-large\">resource from Arduino themselves</a><span class=\"ql-size-large\">.</span></p><p><span class=\"ql-size-large\">This code is free for your use (as in no cost and to be modified as you please), please attribute where you should.</span></p><p><br></p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\"><span class=\"hljs-comment\">/*******Interrupt-based Rotary Encoder Sketch*******\n" +
   "by Simon Merrett, based on insight from Oleg Mazurov, Nick Gammon, rt, Steve Spence\n" +
   "*/</span>\n" +
   "\n" +
   "<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> pinA = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// Our first hardware interrupt pin is digital pin 2</span>\n" +
   "<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> pinB = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// Our second hardware interrupt pin is digital pin 3</span>\n" +
   "<span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">byte</span> aFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// let's us know when we're expecting a rising edge on pinA to signal that the encoder has arrived at a detent</span>\n" +
   "<span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">byte</span> bFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// let's us know when we're expecting a rising edge on pinB to signal that the encoder has arrived at a detent (opposite direction to when aFlag is set)</span>\n" +
   "<span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">byte</span> encoderPos = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//this variable stores our current value of encoder position. Change to int or uin16_t instead of byte if you want to record a larger range than 0-255</span>\n" +
   "<span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">byte</span> oldEncPos = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//stores the last encoder position value so we can compare to the current reading and see if it has changed (so we know when to print to the serial monitor)</span>\n" +
   "<span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-keyword\">byte</span> reading = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//somewhere to store the direct values we read from our interrupt pins before checking to see if we have moved a whole detent</span>\n" +
   "\n" +
   "<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setup</span>() </span>{\n" +
   "  pinMode(pinA, INPUT_PULLUP); <span class=\"hljs-comment\">// set pinA as an input, pulled HIGH to the logic voltage (5V or 3.3V for most cases)</span>\n" +
   "  pinMode(pinB, INPUT_PULLUP); <span class=\"hljs-comment\">// set pinB as an input, pulled HIGH to the logic voltage (5V or 3.3V for most cases)</span>\n" +
   "  attachInterrupt(<span class=\"hljs-number\">0</span>,PinA,RISING); <span class=\"hljs-comment\">// set an interrupt on PinA, looking for a rising edge signal and executing the \"PinA\" Interrupt Service Routine (below)</span>\n" +
   "  attachInterrupt(<span class=\"hljs-number\">1</span>,PinB,RISING); <span class=\"hljs-comment\">// set an interrupt on PinB, looking for a rising edge signal and executing the \"PinB\" Interrupt Service Routine (below)</span>\n" +
   "  Serial.begin(<span class=\"hljs-number\">115200</span>); <span class=\"hljs-comment\">// start the serial monitor link</span>\n" +
   "}\n" +
   "\n" +
   "<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PinA</span>()</span>{\n" +
   "  cli(); <span class=\"hljs-comment\">//stop interrupts happening before we read pin values</span>\n" +
   "  reading = PIND &amp; <span class=\"hljs-number\">0xC</span>; <span class=\"hljs-comment\">// read all eight pin values then strip away all but pinA and pinB's values</span>\n" +
   "  <span class=\"hljs-keyword\">if</span>(reading == B00001100 &amp;&amp; aFlag) { <span class=\"hljs-comment\">//check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge</span>\n" +
   "    encoderPos --; <span class=\"hljs-comment\">//decrement the encoder's position count</span>\n" +
   "    bFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//reset flags for the next turn</span>\n" +
   "    aFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//reset flags for the next turn</span>\n" +
   "  }\n" +
   "  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (reading == B00000100) bFlag = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//signal that we're expecting pinB to signal the transition to detent from free rotation</span>\n" +
   "  sei(); <span class=\"hljs-comment\">//restart interrupts</span>\n" +
   "}\n" +
   "\n" +
   "<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">PinB</span>()</span>{\n" +
   "  cli(); <span class=\"hljs-comment\">//stop interrupts happening before we read pin values</span>\n" +
   "  reading = PIND &amp; <span class=\"hljs-number\">0xC</span>; <span class=\"hljs-comment\">//read all eight pin values then strip away all but pinA and pinB's values</span>\n" +
   "  <span class=\"hljs-keyword\">if</span> (reading == B00001100 &amp;&amp; bFlag) { <span class=\"hljs-comment\">//check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge</span>\n" +
   "    encoderPos ++; <span class=\"hljs-comment\">//increment the encoder's position count</span>\n" +
   "    bFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//reset flags for the next turn</span>\n" +
   "    aFlag = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//reset flags for the next turn</span>\n" +
   "  }\n" +
   "  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (reading == B00001000) aFlag = <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//signal that we're expecting pinA to signal the transition to detent from free rotation</span>\n" +
   "  sei(); <span class=\"hljs-comment\">//restart interrupts</span>\n" +
   "}\n" +
   "\n" +
   "<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">loop</span>()</span>{\n" +
   "  <span class=\"hljs-keyword\">if</span>(oldEncPos != encoderPos) {\n" +
   "    Serial.println(encoderPos);\n" +
   "    oldEncPos = encoderPos;\n" +
   "  }\n" +
   "}\n" +
   "\n" +
   "</pre><p><br></p><p><span style=\"color: rgb(51, 51, 51);\">That's it!</span></p>",
  project_id: p4.id,
)


Step.create(
  title: "Conclusion",
 body:
  "<p><span class=\"ql-size-large\">I hope you find this code useful for your next project which uses a rotary encoder or that it has inspired you to consider a rotary encoder as an input for your next project.</span></p><p><strong class=\"ql-size-large\">Summary of the Aims</strong></p><p><span class=\"ql-size-large\">I have tried to write some code which achieves a good balance of:</span></p><ul><li><span class=\"ql-size-large\">Portability (port manipulation code is the compromise when moving to other chips)</span></li><li><span class=\"ql-size-large\">Speed (port manipulation really helps)</span></li><li><span class=\"ql-size-large\">Low compiled code size (port manipulation and bitmath helps)</span></li><li><span class=\"ql-size-large\">Reliably records slow and fast manual rotation</span></li><li><span class=\"ql-size-large\">Reduced nugatory interrupt service routine calls (using RISING interrupt and temporarily disabling interrupts)</span></li></ul><p><strong class=\"ql-size-large\">Caveats and Ideas for Improvement</strong></p><p><span class=\"ql-size-large\">This code isn't perfect by any means and you might like to change it to use other pins. I tested this code with the sketch which was causing the most delay and least reliable readings with the other approaches discussed - I certainly haven't compared it with timers to see whose code produces fewer nugatory interrupt service routines, takes the least time to execute or filters out the highest percentage of contact bounces. Perhaps someone might like to do a benchmark test against the other approaches out there.</span></p>",
 project_id: p4.id,
)
